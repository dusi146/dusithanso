document.addEventListener('DOMContentLoaded', () => {
    const introOverlay = document.getElementById('intro-overlay');
    const mainContent = document.querySelector('.main-content');
    const fullNameInput = document.getElementById('fullNameInput');
    const dobInput = document.getElementById('dobInput');
    const phoneNumberInput = document.getElementById('phoneNumberInput');
    const checkButton = document.getElementById('checkButton');
    const findGoodNumberButton = document.getElementById('findGoodNumberButton');
    const resultDiv = document.getElementById('result');
    const loadingOverlay = document.getElementById('loading');
    const spinner = loadingOverlay.querySelector('.spinner');
    const checkmarkWrapper = loadingOverlay.querySelector('.checkmark-wrapper');
    const langToggleButton = document.getElementById('lang-toggle');
    const themeToggleButton = document.getElementById('theme-toggle');
    const carrierModal = document.getElementById('carrierModal');
    const closeButton = carrierModal.querySelector('.close-button');
    const searchGoodNumberButton = document.getElementById('searchGoodNumberButton');

    let currentLang = 'vi'; // Default language
    let currentTheme = 'dark'; // Default theme

    const translations = {
        vi: {
            pageTitle: "üîÆ S·ªë Phong Th·ªßy üîÆ",
            mainTitle: "üîÆ S·ªë Phong Th·ªßy üîÆ",
            slogan: "Kh√°m ph√° b√≠ ·∫©n ƒë·∫±ng sau d√£y s·ªë c·ªßa b·∫°n",
            placeholderFullName: "H·ªç v√† t√™n c·ªßa b·∫°n",
            placeholderPhoneNumber: "Nh·∫≠p s·ªë ƒëi·ªán tho·∫°i (10 ch·ªØ s·ªë)",
            buttonPredict: "Ti√™n Tri Ngay!",
            buttonFindGood: "S·ªë H·ª£p M·ªánh",
            initialMessage: "Nh·∫≠p th√¥ng tin c·ªßa m√†y v√†o √¥ tr√™n ƒë·ªÉ b·∫Øt ƒë·∫ßu kh√°m ph√° v·∫≠n m·ªánh!",
            disclaimer: "L∆∞u √Ω: ƒê√¢y ch·ªâ l√† c√¥ng c·ª• gi·∫£i tr√≠ d·ª±a tr√™n c√°c quan ni·ªám phong th·ªßy v√† d√¢n gian. Kh√¥ng n√™n qu√° tin t∆∞·ªüng!",
            langToggle: "ENG",
            chooseCarrier: "Ch·ªçn Nh√† M·∫°ng",
            buttonSearch: "D√≤ S·ªë",
            validPhoneLength: "S·ªë ƒëi·ªán tho·∫°i ph·∫£i c√≥ ƒë√∫ng 10 ch·ªØ s·ªë.",
            invalidPhonePrefix: "S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá (Vi·ªát Nam c√≥ 10 s·ªë, b·∫Øt ƒë·∫ßu b·∫±ng 0).",
            invalidDate: "Ng√†y sinh kh√¥ng h·ª£p l·ªá.",
            invalidName: "H·ªç v√† t√™n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.",
            resultTitle: "K·∫æT QU·∫¢ TI√äN TRI",
            number: "S·ªë ƒëi·ªán tho·∫°i:",
            score: "ƒêi·ªÉm phong th·ªßy:",
            meaning: "√ù nghƒ©a t·ªïng qu√°t:",
            carrier: "Nh√† m·∫°ng:",
            introSuccess: "Gi·ªõi thi·ªáu th√†nh c√¥ng",
            processing: "ƒêang x·ª≠ l√Ω...",
            findingGoodNumber: "ƒêang d√≤ t√¨m s·ªë h·ª£p m·ªánh...",
            goodNumberFound: "ƒê√£ t√¨m th·∫•y s·ªë h·ª£p m·ªánh!",
            noGoodNumber: "Kh√¥ng t√¨m ƒë∆∞·ª£c s·ªë h·ª£p m·ªánh n√†o trong gi·ªõi h·∫°n cho ph√©p.",
            detailPrefix: "√ù nghƒ©a c√°c s·ªë ƒë·∫ßu (qu·∫ª d·ªãch):",
            detailSuffix: "√ù nghƒ©a c√°c s·ªë cu·ªëi (n√∫t sim, t·ªïng n√∫t):",
            detailOverall: "ƒê√°nh gi√° t·ªïng quan:",
            detailGoodLuck: "C√°t T∆∞·ªùng (ƒêi·ªÉm t·ªët):",
            detailBadLuck: "Hung √Åc (ƒêi·ªÉm x·∫•u):",
            detailBalance: "C√¢n B·∫±ng (Trung h√≤a):",
            noCarrierSelected: "Vui l√≤ng ch·ªçn m·ªôt nh√† m·∫°ng tr∆∞·ªõc khi d√≤ s·ªë.",
            errorOccurred: "ƒê√£ x·∫£y ra l·ªói. Vui l√≤ng th·ª≠ l·∫°i.",
            loadingCarrierData: "ƒêang t·∫£i d·ªØ li·ªáu nh√† m·∫°ng..."
        },
        en: {
            pageTitle: "üîÆ Feng Shui Numbers üîÆ",
            mainTitle: "üîÆ Feng Shui Numbers üîÆ",
            slogan: "Discover the mystery behind your numbers",
            placeholderFullName: "Your full name",
            placeholderPhoneNumber: "Enter phone number (10 digits)",
            buttonPredict: "Predict Now!",
            buttonFindGood: "Find Lucky Number",
            initialMessage: "Enter your information above to start exploring your destiny!",
            disclaimer: "Note: This is an entertainment tool based on feng shui and folk beliefs. Do not rely too heavily on it!",
            langToggle: "VIE",
            chooseCarrier: "Choose Carrier",
            buttonSearch: "Search Number",
            validPhoneLength: "Phone number must be exactly 10 digits.",
            invalidPhonePrefix: "Invalid phone number (Vietnamese numbers are 10 digits, starting with 0).",
            invalidDate: "Invalid date of birth.",
            invalidName: "Full name cannot be empty.",
            resultTitle: "PREDICTION RESULT",
            number: "Phone Number:",
            score: "Feng Shui Score:",
            meaning: "Overall Meaning:",
            carrier: "Carrier:",
            introSuccess: "Intro loaded successfully",
            processing: "Processing...",
            findingGoodNumber: "Searching for a lucky number...",
            goodNumberFound: "Lucky number found!",
            noGoodNumber: "No lucky number found within the allowed attempts.",
            detailPrefix: "Meaning of initial digits (Hexagram):",
            detailSuffix: "Meaning of final digits (SIM points, total points):",
            detailOverall: "Overall assessment:",
            detailGoodLuck: "Auspicious (Good points):",
            detailBadLuck: "Inauspicious (Bad points):",
            detailBalance: "Balance (Neutral):",
            noCarrierSelected: "Please select a carrier before searching for a number.",
            errorOccurred: "An error occurred. Please try again.",
            loadingCarrierData: "Loading carrier data..."
        }
    };

    const updateContent = () => {
        document.querySelectorAll('[data-lang-key]').forEach(element => {
            const key = element.dataset.langKey;
            if (translations[currentLang][key]) {
                if (element.tagName === 'INPUT' && element.hasAttribute('placeholder')) {
                    element.setAttribute('placeholder', translations[currentLang][key]);
                } else {
                    element.textContent = translations[currentLang][key];
                }
            }
        });
        // Special case for language toggle button text
        langToggleButton.querySelector('.lang-text').textContent = currentLang === 'vi' ? 'ENG' : 'VIE';
    };

    const toggleTheme = () => {
        currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
        document.body.classList.toggle('light-theme', currentTheme === 'light');
        const icon = themeToggleButton.querySelector('i');
        icon.classList.remove('fa-sun', 'fa-moon');
        icon.classList.add(currentTheme === 'dark' ? 'fa-sun' : 'fa-moon');
    };

    langToggleButton.addEventListener('click', () => {
        currentLang = currentLang === 'vi' ? 'en' : 'vi';
        updateContent();
    });

    themeToggleButton.addEventListener('click', toggleTheme);

    // Initial content update and theme setting
    updateContent();
    document.body.classList.add(currentTheme + '-theme'); // Apply initial theme class

    // Simulate intro loading
    setTimeout(() => {
        introOverlay.classList.add('hidden');
        mainContent.classList.add('show');
    }, 2000); // Intro lasts 2 seconds

    // DO NOT set dobInput.valueAsDate = new Date(); to leave it empty initially

    const getLunarInfo = (dob) => {
        // Simple mock for lunar info, in a real app this would be a complex calculation or API call
        const year = dob.getFullYear();
        if (year < 1900 || year > 2050) return { zodiac: 'N/A', destiny: 'N/A', element: 'N/A' };

        const zodiacAnimals = {
            vi: ["Th√¢n", "D·∫≠u", "Tu·∫•t", "H·ª£i", "T√Ω", "S·ª≠u", "D·∫ßn", "M√£o", "Th√¨n", "T·ªµ", "Ng·ªç", "M√πi"],
            en: ["Monkey", "Rooster", "Dog", "Pig", "Rat", "Ox", "Tiger", "Rabbit", "Dragon", "Snake", "Horse", "Goat"]
        };
        const elements = {
            vi: ["Kim", "M·ªôc", "Th·ªßy", "H·ªèa", "Th·ªï"],
            en: ["Metal", "Wood", "Water", "Fire", "Earth"]
        };

        const canChiTuongSinhTuongKhac = [
            // Can: Gi√°p, ·∫§t, B√≠nh, ƒêinh, M·∫≠u, K·ª∑, Canh, T√¢n, Nh√¢m, Qu√Ω
            // Chi: T√Ω, S·ª≠u, D·∫ßn, M√£o, Th√¨n, T·ªµ, Ng·ªç, M√πi, Th√¢n, D·∫≠u, Tu·∫•t, H·ª£i
            // Element: Kim, M·ªôc, Th·ªßy, H·ªèa, Th·ªï
            // Simplified elemental mapping for destiny based on year cycle (l·ª•c th·∫≠p hoa gi√°p simplified)
            { year: 1984, element: 'Kim', canChi: 'Gi√°p T√Ω' }, { year: 1985, element: 'Kim', canChi: '·∫§t S·ª≠u' },
            { year: 1986, element: 'H·ªèa', canChi: 'B√≠nh D·∫ßn' }, { year: 1987, element: 'H·ªèa', canChi: 'ƒêinh M√£o' },
            { year: 1988, element: 'M·ªôc', canChi: 'M·∫≠u Th√¨n' }, { year: 1989, element: 'M·ªôc', canChi: 'K·ª∑ T·ªµ' },
            { year: 1990, element: 'Th·ªï', canChi: 'Canh Ng·ªç' }, { year: 1991, element: 'Th·ªï', canChi: 'T√¢n M√πi' },
            { year: 1992, element: 'Kim', canChi: 'Nh√¢m Th√¢n' }, { year: 1993, element: 'Kim', canChi: 'Qu√Ω D·∫≠u' },
            { year: 1994, element: 'H·ªèa', canChi: 'Gi√°p Tu·∫•t' }, { year: 1995, element: 'H·ªèa', canChi: '·∫§t H·ª£i' },
            { year: 1996, element: 'Th·ªßy', canChi: 'B√≠nh T√Ω' }, { year: 1997, element: 'Th·ªßy', canChi: 'ƒêinh S·ª≠u' },
            { year: 1998, element: 'Th·ªï', canChi: 'M·∫≠u D·∫ßn' }, { year: 1999, element: 'Th·ªï', canChi: 'K·ª∑ M√£o' },
            { year: 2000, element: 'Kim', canChi: 'Canh Th√¨n' }, { year: 2001, element: 'Kim', canChi: 'T√¢n T·ªµ' },
            { year: 2002, element: 'M·ªôc', canChi: 'Nh√¢m Ng·ªç' }, { year: 2003, element: 'M·ªôc', canChi: 'Qu√Ω M√πi' },
            { year: 2004, element: 'Th·ªßy', canChi: 'Gi√°p Th√¢n' }, { year: 2005, element: 'Th·ªßy', canChi: '·∫§t D·∫≠u' },
            { year: 2006, element: 'H·ªèa', canChi: 'B√≠nh Tu·∫•t' }, { year: 2007, element: 'H·ªèa', canChi: 'ƒêinh H·ª£i' },
            { year: 2008, element: 'Th·ªï', canChi: 'M·∫≠u T√Ω' }, { year: 2009, element: 'Th·ªï', canChi: 'K·ª∑ S·ª≠u' },
            { year: 2010, element: 'M·ªôc', canChi: 'Canh D·∫ßn' }, { year: 2011, element: 'M·ªôc', canChi: 'T√¢n M√£o' },
            { year: 2012, element: 'Th·ªßy', canChi: 'Nh√¢m Th√¨n' }, { year: 2013, element: 'Th·ªßy', canChi: 'Qu√Ω T·ªµ' },
            { year: 2014, element: 'Kim', canChi: 'Gi√°p Ng·ªç' }, { year: 2015, element: 'Kim', canChi: '·∫§t M√πi' },
            { year: 2016, element: 'H·ªèa', canChi: 'B√≠nh Th√¢n' }, { year: 2017, element: 'H·ªèa', canChi: 'ƒêinh D·∫≠u' },
            { year: 2018, element: 'M·ªôc', canChi: 'M·∫≠u Tu·∫•t' }, { year: 2019, element: 'M·ªôc', canChi: 'K·ª∑ H·ª£i' },
            { year: 2020, element: 'Th·ªï', canChi: 'Canh T√Ω' }, { year: 2021, element: 'Th·ªï', canChi: 'T√¢n S·ª≠u' },
            { year: 2022, element: 'Kim', canChi: 'Nh√¢m D·∫ßn' }, { year: 2023, element: 'Kim', canChi: 'Qu√Ω M√£o' },
            { year: 2024, element: 'H·ªèa', canChi: 'Gi√°p Th√¨n' }, { year: 2025, element: 'H·ªèa', canChi: '·∫§t T·ªµ' },
        ];

        const lunarYearData = canChiTuongSinhTuongKhac.find(data => data.year === year);
        const destiny = lunarYearData ? `${lunarYearData.canChi} (${lunarYearData.element})` : 'N/A';
        const element = lunarYearData ? lunarYearData.element : 'N/A';

        return {
            zodiac: zodiacAnimals[currentLang][(year - 4) % 12],
            destiny: destiny,
            element: element
        };
    };

    const getCarrier = (phoneNumber) => {
        if (!phoneNumber || phoneNumber.length < 3) return 'Unknown';
        const prefix = phoneNumber.substring(0, 3);
        const prefixes = {
            '086': 'Viettel', '096': 'Viettel', '097': 'Viettel', '098': 'Viettel',
            '032': 'Viettel', '033': 'Viettel', '034': 'Viettel', '035': 'Viettel', '036': 'Viettel',
            '037': 'Viettel', '038': 'Viettel', '039': 'Viettel',

            '089': 'Mobifone', '090': 'Mobifone', '093': 'Mobifone',
            '070': 'Mobifone', '079': 'Mobifone', '077': 'Mobifone', '076': 'Mobifone', '078': 'Mobifone',

            '081': 'Vinaphone', '082': 'Vinaphone', '083': 'Vinaphone', '084': 'Vinaphone', '085': 'Vinaphone',
            '088': 'Vinaphone', '091': 'Vinaphone', '094': 'Vinaphone',

            '092': 'Vietnamobile', '056': 'Vietnamobile', '058': 'Vietnamobile',

            '099': 'Gmobile', '059': 'Gmobile'
        };
        return prefixes[prefix] || 'Unknown';
    };

    const calculateTotalScore = (number) => {
        return number.split('').reduce((sum, digit) => sum + parseInt(digit), 0);
    };

    const analyzeNumberMeaning = (number, fullName, dobString) => {
        // Validate inputs before proceeding
        if (!fullName || !dobString || !number || number.length !== 10) {
            throw new Error(currentLang === 'vi' ? "Th√¥ng tin ƒë·∫ßu v√†o kh√¥ng h·ª£p l·ªá ƒë·ªÉ ph√¢n t√≠ch s·ªë." : "Invalid input for number analysis.");
        }

        const dob = new Date(dobString);
        if (isNaN(dob.getTime())) { // Check if date is valid
            throw new Error(currentLang === 'vi' ? "Ng√†y sinh kh√¥ng h·ª£p l·ªá." : "Invalid date of birth.");
        }

        const lunarInfo = getLunarInfo(dob);
        const totalScore = calculateTotalScore(number);
        const lastFourDigits = number.substring(number.length - 4);
        const firstThreeDigits = number.substring(0, 3);
        const carrier = getCarrier(number);

        // Simple mock for hexagram and suffix meanings
        const hexagramMeaning = getHexagramMeaning(firstThreeDigits, currentLang);
        const suffixMeaning = getSuffixMeaning(lastFourDigits, currentLang);
        const totalScoreMeaning = getTotalScoreMeaning(totalScore, currentLang);

        const goodPoints = [];
        const badPoints = [];
        const neutralPoints = [];

        // Example scoring logic (simplified for demonstration)
        let overallScore = 0;

        // Base score for total digits
        if (totalScore % 10 === 8 || totalScore % 10 === 9) {
            goodPoints.push(currentLang === 'vi' ? `T·ªïng n√∫t cao (${totalScore}) mang l·∫°i may m·∫Øn, t√†i l·ªôc.` : `High total sum (${totalScore}) brings luck and wealth.`);
            overallScore += 20;
        } else if (totalScore % 10 === 0 || totalScore % 10 === 4 || totalScore % 10 === 7) {
            badPoints.push(currentLang === 'vi' ? `T·ªïng n√∫t kh√¥ng t·ªët (${totalScore}) c√≥ th·ªÉ mang l·∫°i c·∫£n tr·ªü.` : `Bad total sum (${totalScore}) may bring obstacles.`);
            overallScore -= 15;
        } else {
            neutralPoints.push(currentLang === 'vi' ? `T·ªïng n√∫t v·ª´a ph·∫£i (${totalScore}).` : `Moderate total sum (${totalScore}).`);
        }

        // Score based on final digits (e.g., "th·∫ßn t√†i", "l·ªôc ph√°t")
        if (lastFourDigits.endsWith('39') || lastFourDigits.endsWith('79')) { // Th·∫ßn t√†i
            goodPoints.push(currentLang === 'vi' ? `ƒêu√¥i Th·∫ßn T√†i (${lastFourDigits.slice(-2)}) gi√∫p thu h√∫t t√†i l·ªôc.` : `"God of Wealth" ending (${lastFourDigits.slice(-2)}) attracts wealth.`);
            overallScore += 25;
        } else if (lastFourDigits.endsWith('68') || lastFourDigits.endsWith('86')) { // L·ªôc ph√°t
            goodPoints.push(currentLang === 'vi' ? `ƒêu√¥i L·ªôc Ph√°t (${lastFourDigits.slice(-2)}) mang l·∫°i s·ª± ph√°t tri·ªÉn.` : `"Prosperity" ending (${lastFourDigits.slice(-2)}) brings growth.`);
            overallScore += 25;
        } else if (lastFourDigits.endsWith('49') || lastFourDigits.endsWith('53')) { // Hung (simplified)
            badPoints.push(currentLang === 'vi' ? `ƒêu√¥i s·ªë x·∫•u (${lastFourDigits.slice(-2)}) c√≥ th·ªÉ g·∫∑p r·∫Øc r·ªëi.` : `Bad ending digits (${lastFourDigits.slice(-2)}) may cause trouble.`);
            overallScore -= 20;
        }

        // Score based on sequential numbers (g√°nh ƒë·∫£o, ti·∫øn l√™n)
        const isAscending = (n) => {
            for (let i = 0; i < n.length - 1; i++) {
                if (parseInt(n[i]) >= parseInt(n[i+1])) return false;
            }
            return true;
        };
        const isDescending = (n) => {
            for (let i = 0; i < n.length - 1; i++) {
                if (parseInt(n[i]) <= parseInt(n[i+1])) return false;
            }
            return true;
        };
        const hasRepetitive = (n) => /(.)\1{2,}/.test(n); // Three or more identical digits

        if (isAscending(number.slice(3, 7)) || isDescending(number.slice(3, 7))) { // Example for mid-section
            goodPoints.push(currentLang === 'vi' ? "D√£y s·ªë gi·ªØa c√≥ s·ª± s·∫Øp x·∫øp ti·∫øn/l√πi ƒë·∫πp." : "Middle digits have good ascending/descending order.");
            overallScore += 10;
        }
        if (hasRepetitive(number)) {
            badPoints.push(currentLang === 'vi' ? "S·ªë c√≥ d√£y l·∫∑p l·∫°i qu√° nhi·ªÅu, c√≥ th·ªÉ kh√¥ng t·ªët." : "Number has too many repetitive digits, which may not be good.");
            overallScore -= 10;
        }

        // Compatibility with Birth Element (simplified)
        // Convert overall number "element" (last digit parity/sum) to an element
        const lastDigit = parseInt(number.slice(-1));
        let numberElement = '';
        if ([1, 2].includes(lastDigit)) numberElement = 'M·ªôc';
        else if ([3, 4].includes(lastDigit)) numberElement = 'H·ªèa';
        else if ([5, 6].includes(lastDigit)) numberElement = 'Th·ªï';
        else if ([7, 8].includes(lastDigit)) numberElement = 'Kim';
        else if ([9, 0].includes(lastDigit)) numberElement = 'Th·ªßy';

        const birthElement = lunarInfo.element;
        const ng≈©HanhSinhKhac = {
            'Kim': { sinh: 'Th·ªßy', khac: 'M·ªôc' },
            'M·ªôc': { sinh: 'H·ªèa', khac: 'Th·ªï' },
            'Th·ªßy': { sinh: 'M·ªôc', khac: 'H·ªèa', hoaGiai: ['Kim', 'Th·ªï'] }, // Th·ªßy kh·∫Øc H·ªèa, M·ªôc h√≥a gi·∫£i. Kim v√† Th·ªï c≈©ng h·ªó tr·ª£ Th·ªßy.
            'H·ªèa': { sinh: 'Th·ªï', khac: 'Kim' },
            'Th·ªï': { sinh: 'Kim', khac: 'Th·ªßy' }
        };
        
        // Enhance element interaction logic
        if (birthElement && ng≈©HanhSinhKhac[birthElement]) {
            if (ng≈©HanhSinhKhac[birthElement].sinh === numberElement) {
                goodPoints.push(currentLang === 'vi' ? `M·ªánh c·ªßa s·ªë (${numberElement}) T∆∞∆°ng Sinh v·ªõi M·ªánh c·ªßa b·∫°n (${birthElement}). R·∫•t t·ªët!` : `The number's element (${numberElement}) is compatible (produces) with your birth element (${birthElement}). Very good!`);
                overallScore += 30;
            } else if (ng≈©HanhSinhKhac[birthElement].khac === numberElement) {
                badPoints.push(currentLang === 'vi' ? `M·ªánh c·ªßa s·ªë (${numberElement}) T∆∞∆°ng Kh·∫Øc v·ªõi M·ªánh c·ªßa b·∫°n (${birthElement}). Kh√¥ng t·ªët.` : `The number's element (${numberElement}) clashes with your birth element (${birthElement}). Not good.`);
                overallScore -= 25;
            } else if (numberElement === birthElement) {
                neutralPoints.push(currentLang === 'vi' ? `M·ªánh c·ªßa s·ªë (${numberElement}) v√† M·ªánh c·ªßa b·∫°n (${birthElement}) l√† B√¨nh H√≤a (c√πng m·ªánh).` : `The number's element (${numberElement}) and your birth element (${birthElement}) are in harmony (same element).`);
                overallScore += 10; // Slightly positive for being the same element
            } else if (ng≈©HanhSinhKhac[numberElement] && ng≈©HanhSinhKhac[numberElement].sinh === birthElement) {
                 neutralPoints.push(currentLang === 'vi' ? `M·ªánh c·ªßa s·ªë (${numberElement}) ƒë∆∞·ª£c M·ªánh c·ªßa b·∫°n (${birthElement}) T∆∞∆°ng Sinh (B·∫°n sinh s·ªë).` : `The number's element (${numberElement}) is produced by your birth element (${birthElement}).`);
                 overallScore += 5; // Good, but less than number generating birth element
            }
            else {
                neutralPoints.push(currentLang === 'vi' ? `M·ªánh c·ªßa s·ªë (${numberElement}) v√† M·ªánh c·ªßa b·∫°n (${birthElement}) l√† B√¨nh H√≤a.` : `The number's element (${numberElement}) and your birth element (${birthElement}) are in balance.`);
                overallScore += 5;
            }
        }


        // Determine overall assessment based on score
        let overallAssessment = '';
        let resultClass = '';
        if (overallScore >= 60) {
            overallAssessment = currentLang === 'vi' ? "ƒê√¢y l√† m·ªôt s·ªë ƒëi·ªán tho·∫°i C·ª∞C K·ª≤ MAY M·∫ÆN, mang l·∫°i nhi·ªÅu t√†i l·ªôc v√† hanh th√¥ng." : "This is an EXTREMELY LUCKY phone number, bringing much wealth and smooth sailing.";
            resultClass = 'good-number';
        } else if (overallScore >= 30) {
            overallAssessment = currentLang === 'vi' ? "S·ªë ƒëi·ªán tho·∫°i n√†y T·ªêT, c√≥ th·ªÉ mang l·∫°i nh·ªØng ƒëi·ªÅu t√≠ch c·ª±c." : "This phone number is GOOD, potentially bringing positive things.";
            resultClass = 'good-number';
        } else if (overallScore >= 0) {
            overallAssessment = currentLang === 'vi' ? "S·ªë ƒëi·ªán tho·∫°i ·ªü m·ª©c TRUNG B√åNH, kh√¥ng qu√° t·ªët c≈©ng kh√¥ng qu√° x·∫•u." : "This phone number is AVERAGE, neither particularly good nor bad.";
            resultClass = 'neutral-number';
        } else {
            overallAssessment = currentLang === 'vi' ? "S·ªë ƒëi·ªán tho·∫°i n√†y KH√îNG T·ªêT, c√≥ th·ªÉ g·∫∑p nhi·ªÅu kh√≥ khƒÉn, tr·∫Øc tr·ªü." : "This phone number is NOT GOOD, potentially leading to many difficulties and obstacles.";
            resultClass = 'bad-number';
        }


        const goodLuckHtml = goodPoints.length > 0 ? `<p><strong>${translations[currentLang].detailGoodLuck}</strong></p><ul>${goodPoints.map(p => `<li>${p}</li>`).join('')}</ul>` : '';
        const badLuckHtml = badPoints.length > 0 ? `<p><strong>${translations[currentLang].detailBadLuck}</strong></p><ul>${badPoints.map(p => `<li>${p}</li>`).join('')}</ul>` : '';
        const balanceHtml = neutralPoints.length > 0 ? `<p><strong>${translations[currentLang].detailBalance}</strong></p><ul>${neutralPoints.map(p => `<li>${p}</li>`).join('')}</ul>` : '';

        return {
            html: `
                <h3 class="${resultClass}">${translations[currentLang].resultTitle}</h3>
                <p><strong>${translations[currentLang].number}</strong> <span class="${resultClass}">${number}</span></p>
                <p><strong>${translations[currentLang].score}</strong> <span class="${resultClass}">${overallScore} / 100</span></p>
                <p><strong>${translations[currentLang].meaning}</strong> <span class="${resultClass}">${overallAssessment}</span></p>
                <p><strong>${translations[currentLang].carrier}</strong> ${carrier}</p>
                <p><strong>${translations[currentLang].placeholderFullName}:</strong> ${fullName}</p>
                <p><strong>${currentLang === 'vi' ? 'Ng√†y sinh:' : 'Date of Birth:'}</strong> ${dobString}</p>
                <p><strong>${currentLang === 'vi' ? 'Tu·ªïi √Çm L·ªãch:' : 'Lunar Age:'}</strong> ${lunarInfo.zodiac} (${lunarInfo.destiny})</p>
                
                <h4>${translations[currentLang].detailPrefix}</h4>
                <p>${hexagramMeaning}</p>
                
                <h4>${translations[currentLang].detailSuffix}</h4>
                <p>${suffixMeaning}</p>

                <h4>${translations[currentLang].detailOverall}</h4>
                ${goodLuckHtml}
                ${badLuckHtml}
                ${balanceHtml}
            `,
            overallScore: overallScore // Return score for comparison
        };
    };

    function getHexagramMeaning(firstThreeDigits, lang) {
        // More comprehensive (but still not exhaustive) mapping based on first 3 digits (mock data)
        // These mappings are simplified and illustrative, not based on full I-Ching calculations
        const mappings = {
            '032': { vi: "Qu·∫ª: H·ªèa ƒê·ªãa T·∫•n (Ti·∫øn l√™n). √ù nghƒ©a: C√≥ √Ω nghƒ©a ti·∫øn l√™n, ph√°t tri·ªÉn m·∫°nh m·∫Ω, ƒë∆∞·ª£c qu√Ω nh√¢n ph√π tr·ª£. R·∫•t t·ªët cho s·ª± nghi·ªáp v√† c√¥ng danh.", en: "Hexagram: Fire on Earth (Progress). Meaning: Signifies strong progress and development, supported by benefactors. Very good for career and reputation." },
            '033': { vi: "Qu·∫ª: Thi√™n L√¥i V√¥ V·ªçng (Kh√¥ng c√≥ g√¨ sai). √ù nghƒ©a: Thu·∫≠n theo t·ª± nhi√™n, tr√°nh c∆∞·ª°ng c·∫ßu. M·ªçi s·ª± b√¨nh an n·∫øu kh√¥ng l√†m ƒëi·ªÅu tr√°i l·∫Ω.", en: "Hexagram: Heaven over Thunder (Without Error). Meaning: Follow natural course, avoid forcing things. Peace if actions are just." },
            '034': { vi: "Qu·∫ª: Phong ƒê·ªãa Quan (Quan s√°t). √ù nghƒ©a: C·∫ßn quan s√°t k·ªπ l∆∞·ª°ng, th·∫≠n tr·ªçng tr∆∞·ªõc khi h√†nh ƒë·ªông. C√≥ c∆° h·ªôi nh∆∞ng ph·∫£i bi·∫øt n·∫Øm b·∫Øt.", en: "Hexagram: Wind over Earth (Contemplation). Meaning: Observe carefully, be cautious before acting. Opportunities exist but must be seized wisely." },
            '035': { vi: "Qu·∫ª: Th·ªßy ƒê·ªãa T·ª∑ (So s√°nh, g·∫ßn g≈©i). √ù nghƒ©a: Tinh th·∫ßn h·ª£p t√°c, k·∫øt n·ªëi. Thu·∫≠n l·ª£i trong quan h·ªá ƒë·ªëi t√°c, b·∫°n b√®.", en: "Hexagram: Water over Earth (Holding Together). Meaning: Cooperative spirit, connections. Favorable for partnerships and friendships." },
            '036': { vi: "Qu·∫ª: S∆°n ƒê·ªãa B√°c (Tan r√£). √ù nghƒ©a: Giai ƒëo·∫°n suy tho√°i, c·∫ßn th·∫≠n tr·ªçng v√† b·∫£o to√†n. Tr√°nh m·∫°o hi·ªÉm.", en: "Hexagram: Mountain over Earth (Splitting Apart). Meaning: Period of decline, be cautious and preserve. Avoid risks." },
            '037': { vi: "Qu·∫ª: ƒê·ªãa Tr·∫°ch L√¢m (L√¢m g·∫ßn). √ù nghƒ©a: Ti·∫øn t·ªõi g·∫ßn, c√≥ s·ª± th·ªãnh v∆∞·ª£ng ƒë·∫øn. C·∫ßn ch·ªß ƒë·ªông v√† ki√™n tr√¨.", en: "Hexagram: Earth over Lake (Approach). Meaning: Drawing near, prosperity is coming. Be proactive and persistent." },
            '038': { vi: "Qu·∫ª: L√¥i ƒê·ªãa D·ª± (D·ª± b·ªã, vui v·∫ª). √ù nghƒ©a: H·∫°nh ph√∫c, thu·∫≠n l·ª£i. C·∫ßn chu·∫©n b·ªã k·ªπ l∆∞·ª°ng ƒë·ªÉ duy tr√¨ th√†nh qu·∫£.", en: "Hexagram: Thunder over Earth (Enthusiasm). Meaning: Happiness, favorable. Prepare well to maintain achievements." },
            '039': { vi: "Qu·∫ª: Tr·∫°ch ƒê·ªãa T·ª•y (T·ª• h·ªçp). √ù nghƒ©a: T·∫≠p h·ª£p, t·ª• h·ªçp. T·ªët cho c√°c ho·∫°t ƒë·ªông c·ªông ƒë·ªìng, kinh doanh t·∫≠p th·ªÉ.", en: "Hexagram: Lake over Earth (Gathering). Meaning: Assembly, coming together. Good for community activities, collective business." },

            '070': { vi: "Qu·∫ª: ƒê·ªãa Th·ªßy S∆∞ (Qu√¢n ƒë·ªôi). √ù nghƒ©a: T·ªï ch·ª©c, k·ª∑ lu·∫≠t, c√≥ s·ª©c m·∫°nh t·∫≠p th·ªÉ. Ph√π h·ª£p cho ng∆∞·ªùi l√£nh ƒë·∫°o, qu·∫£n l√Ω.", en: "Hexagram: Earth over Water (Army). Meaning: Organization, discipline, collective strength. Suitable for leaders and managers." },
            '076': { vi: "Qu·∫ª: H·ªèa Th·ªßy V·ªã T·∫ø (Ch∆∞a xong). √ù nghƒ©a: C√¥ng vi·ªác ch∆∞a ho√†n th√†nh, c·∫ßn ti·∫øp t·ª•c c·ªë g·∫Øng, ki√™n nh·∫´n. Cu·ªëi c√πng s·∫Ω th√†nh c√¥ng.", en: "Hexagram: Fire over Water (Not Yet Complete). Meaning: Task incomplete, requires continued effort and patience. Will eventually succeed." },
            '077': { vi: "Qu·∫ª: L√¥i H·ªèa Phong (Phong ph√∫). √ù nghƒ©a: Th·ªãnh v∆∞·ª£ng, ƒë·∫ßy ƒë·ªß. G·∫∑p nhi·ªÅu may m·∫Øn v√† c∆° h·ªôi l·ªõn.", en: "Hexagram: Thunder over Fire (Abundance). Meaning: Prosperity, completeness. Encounter many opportunities and great luck." },
            '078': { vi: "Qu·∫ª: S∆°n H·ªèa B√≠ (Trang tr√≠). √ù nghƒ©a: V·∫ª ƒë·∫πp b√™n ngo√†i, s·ª± tinh t·∫ø. C·∫ßn ch√∫ √Ω ƒë·∫øn n·ªôi dung b√™n trong.", en: "Hexagram: Mountain over Fire (Grace). Meaning: External beauty, refinement. Inner substance also matters." },
            '079': { vi: "Qu·∫ª: Th·ªßy H·ªèa K√Ω T·∫ø (ƒê√£ xong). √ù nghƒ©a: M·ªçi vi·ªác ƒë√£ ho√†n th√†nh, ƒë·∫°t ƒë∆∞·ª£c m·ª•c ti√™u. C·∫ßn gi·ªØ g√¨n th√†nh qu·∫£.", en: "Hexagram: Water over Fire (Already Completed). Meaning: All tasks completed, goals achieved. Maintain accomplishments." },

            '086': { vi: "Qu·∫ª: Phong Thi√™n Ti·ªÉu S√∫c (T√≠ch tr·ªØ nh·ªè). √ù nghƒ©a: T√≠ch l≈©y d·∫ßn d·∫ßn, c√≥ s·ª± kh·ªüi ƒë·∫ßu nh·ªè nh∆∞ng ch·∫Øc ch·∫Øn v√† s·∫Ω ph√°t tri·ªÉn l·ªõn d·∫ßn.", en: "Hexagram: Wind over Heaven (Minor Accumulation). Meaning: Gradual accumulation, small but steady beginning that will grow." },
            '088': { vi: "Qu·∫ª: ƒê·ªãa Thi√™n Th√°i (Th√°i b√¨nh). √ù nghƒ©a: Th√°i b√¨nh, an l·∫°c, m·ªçi s·ª± hanh th√¥ng. R·∫•t t·ªët cho cu·ªôc s·ªëng v√† c√¥ng vi·ªác.", en: "Hexagram: Earth over Heaven (Peace). Meaning: Peace, tranquility, smooth sailing. Very good for life and work." },
            '089': { vi: "Qu·∫ª: Thi√™n Phong C·∫•u (G·∫∑p g·ª°). √ù nghƒ©a: G·∫∑p g·ª°, k·∫øt n·ªëi, c√≥ duy√™n v·ªõi ng∆∞·ªùi kh√°c. T·ªët cho quan h·ªá x√£ h·ªôi, h·ª£p t√°c kinh doanh.", en: "Hexagram: Heaven over Wind (Encountering). Meaning: Encounters, connections, good karma with others. Good for social relationships and business cooperation." },
            
            '090': { vi: "Qu·∫ª: ƒê·ªãa L√¥i Ph·ª•c (Tr·ªü l·∫°i). √ù nghƒ©a: Tr·ªü l·∫°i, ph·ª•c h·ªìi, sau kh√≥ khƒÉn s·∫Ω c√≥ kh·ªüi s·∫Øc m·ªõi. T·ªët cho ng∆∞·ªùi mu·ªën l√†m l·∫°i t·ª´ ƒë·∫ßu.", en: "Hexagram: Earth over Thunder (Returning). Meaning: Returning, restoration, new beginnings after difficulties. Good for those wanting to start anew." },
            '091': { vi: "Qu·∫ª: Th·ªßy Thi√™n Nhu (Ch·ªù ƒë·ª£i). √ù nghƒ©a: C·∫ßn ch·ªù ƒë·ª£i th·ªùi c∆°, ki√™n nh·∫´n s·∫Ω th√†nh c√¥ng. Kh√¥ng n√™n n√≥ng v·ªôi.", en: "Hexagram: Water over Heaven (Waiting). Meaning: Need to wait for the right time, patience will lead to success. Avoid hastiness." },
            '092': { vi: "Qu·∫ª: Phong L√¥i √çch (TƒÉng th√™m). √ù nghƒ©a: TƒÉng th√™m l·ª£i √≠ch, c√≥ s·ª± gia tƒÉng v·ªÅ t√†i l·ªôc v√† may m·∫Øn. R·∫•t t·ªët.", en: "Hexagram: Wind over Thunder (Increase). Meaning: Increased benefits, growth in wealth and luck. Very good." },
            '093': { vi: "Qu·∫ª: Tr·∫°ch Thi√™n Qu·∫£i (Quy·∫øt ƒëo√°n). √ù nghƒ©a: C·∫ßn c√≥ s·ª± quy·∫øt ƒëo√°n, d·ª©t kho√°t ƒë·ªÉ v∆∞·ª£t qua kh√≥ khƒÉn. T·ªët cho l√£nh ƒë·∫°o.", en: "Hexagram: Lake over Heaven (Resolution). Meaning: Requires decisiveness and determination to overcome difficulties. Good for leaders." },
            '094': { vi: "Qu·∫ª: Thi√™n Th·ªßy T·ª•ng (Tranh ch·∫•p). √ù nghƒ©a: C√≥ th·ªÉ g·∫∑p tranh ch·∫•p, ki·ªán t·ª•ng. C·∫ßn gi·∫£i quy·∫øt √¥n h√≤a, tr√°nh xung ƒë·ªôt.", en: "Hexagram: Heaven over Water (Conflict). Meaning: May encounter disputes, lawsuits. Resolve peacefully, avoid conflict." },
            '096': { vi: "Qu·∫ª: Thi√™n Phong C·∫•u (G·∫∑p g·ª°). √ù nghƒ©a: G·∫∑p g·ª°, k·∫øt n·ªëi. C√≥ th·ªÉ t·ªët cho quan h·ªá x√£ h·ªôi, h·ª£p t√°c.", en: "Hexagram: Heaven over Wind (Encountering). Meaning: Encounters and connections. Good for social relationships and cooperation." },
            '097': { vi: "Qu·∫ª: Phong H·ªèa Gia Nh√¢n (Gia ƒë√¨nh). √ù nghƒ©a: H·∫°nh ph√∫c gia ƒë√¨nh, s·ª± h√≤a thu·∫≠n. T·ªët cho cu·ªôc s·ªëng c√° nh√¢n v√† gia ƒë·∫°o.", en: "Hexagram: Wind over Fire (The Family). Meaning: Family happiness, harmony. Good for personal life and household." },
            '098': { vi: "Qu·∫ª: ƒê·ªãa S∆°n Khi√™m (Khi√™m t·ªën). √ù nghƒ©a: Khi√™m t·ªën, nh√∫n nh∆∞·ªùng s·∫Ω ƒë∆∞·ª£c l√≤ng ng∆∞·ªùi v√† ƒë·∫°t th√†nh c√¥ng b·ªÅn v·ªØng.", en: "Hexagram: Earth over Mountain (Modesty). Meaning: Modesty and humility will win hearts and achieve lasting success." },
            '099': { vi: "Qu·∫ª: ƒê·ªãa Tr·∫°ch L√¢m (L√¢m g·∫ßn). √ù nghƒ©a: Ti·∫øn t·ªõi g·∫ßn, c√≥ s·ª± th·ªãnh v∆∞·ª£ng ƒë·∫øn. C·∫ßn ch·ªß ƒë·ªông v√† ki√™n tr√¨.", en: "Hexagram: Earth over Lake (Approach). Meaning: Drawing near, prosperity is coming. Be proactive and persistent." },

            // Add more common prefixes for other carriers if desired
        };
        return mappings[firstThreeDigits] ? mappings[firstThreeDigits][lang] : (lang === 'vi' ? "√ù nghƒ©a qu·∫ª d·ªãch ch∆∞a ƒë∆∞·ª£c c·∫≠p nh·∫≠t cho ƒë·∫ßu s·ªë n√†y." : "Hexagram meaning not updated for this prefix.");
    }

    function getSuffixMeaning(lastFourDigits, lang) {
        // More comprehensive (but still not exhaustive) mapping based on last 4 or 2 digits
        const meanings = {
            // Lucky/Auspicious numbers
            '39': { vi: "Th·∫ßn T√†i Nh·ªè: T√†i l·ªôc, may m·∫Øn v·ªÅ ti·ªÅn b·∫°c. Thu h√∫t v∆∞·ª£ng kh√≠.", en: "Minor God of Wealth: Wealth, financial luck. Attracts prosperity." },
            '79': { vi: "Th·∫ßn T√†i L·ªõn: ƒê·∫°i c√°t, ƒë·∫°i l·ª£i v·ªÅ t√†i ch√≠nh. Ti·ªÅn v√†o nh∆∞ n∆∞·ªõc.", en: "Major God of Wealth: Great fortune and prosperity in finances. Money flows in." },
            '68': { vi: "L·ªôc Ph√°t: Mang l·∫°i t√†i l·ªôc v√† s·ª± ph√°t tri·ªÉn, hanh th√¥ng, c√¥ng vi·ªác thƒÉng ti·∫øn.", en: "Prosperity & Growth: Brings wealth, development, smooth progress, career advancement." },
            '86': { vi: "Ph√°t L·ªôc: Bi·ªÉu t∆∞·ª£ng cho s·ª± ph√°t ƒë·∫°t, thƒÉng ti·∫øn, m·ªü r·ªông l√†m ƒÉn.", en: "Growth & Prosperity: Symbolizes success, advancement, business expansion." },
            '83': { vi: "Ph√°t T√†i: Ph√°t ƒë·∫°t t√†i l·ªôc, kinh doanh thu·∫≠n l·ª£i.", en: "Prosperous Wealth: Business flourishes, easy money." },
            '38': { vi: "Tam Ph√°t: Ph√°t ƒë·∫°t c·∫£ 3 ph∆∞∆°ng di·ªán: c√¥ng danh, t√†i l·ªôc, s·ª©c kh·ªèe.", en: "Triple Growth: Prosperity in three aspects: career, wealth, health." },
            '00': { vi: "Song Kh√¥ng/Tr√≤n Trƒ©nh: S·ª± ƒë·∫ßy ƒë·ªß, vi√™n m√£n, ho·∫∑c kh·ªüi ƒë·∫ßu t·ª´ con s·ªë 0 ƒë·ªÉ v∆∞∆°n l√™n.", en: "Double Zero/Completeness: Fullness, completeness, or starting from zero to rise." },
            '11': { vi: "Nh·∫•t Nh·∫•t/Song Nh·∫•t: ƒê·ªôc nh·∫•t v√¥ nh·ªã, lu√¥n d·∫´n ƒë·∫ßu, ki√™n ƒë·ªãnh.", en: "Double One: Unique, always leading, steadfast." },
            '22': { vi: "Song H·ª∑: H·∫°nh ph√∫c nh√¢n ƒë√¥i, t√¨nh c·∫£m vi√™n m√£n, may m·∫Øn song h√†nh.", en: "Double Happiness: Double joy, fulfilling relationships, luck accompanies." },
            '33': { vi: "Tam T√†i: Thi√™n - ƒê·ªãa - Nh√¢n, may m·∫Øn to√†n di·ªán t·ª´ tr·ªùi ƒë·∫•t ƒë·∫øn con ng∆∞·ªùi.", en: "Triple Talent: Heaven-Earth-Human, comprehensive luck from cosmos to people." },
            '55': { vi: "Song Ng≈©/ƒê·∫°i Ph√∫c: Ph√∫c l·ªôc d·ªìi d√†o, c√¢n b·∫±ng v√† ·ªïn ƒë·ªãnh.", en: "Double Five/Great Fortune: Abundant blessings, balance, and stability." },
            '66': { vi: "L·ªôc L·ªôc/Song L·ªôc: Nh√¢n ƒë√¥i t√†i l·ªôc, may m·∫Øn n·ªëi ti·∫øp may m·∫Øn.", en: "Double Prosperity: Doubles wealth, luck follows luck." },
            '77': { vi: "Th·∫•t ƒê√¥i/ƒê·∫°i Th·∫•t: May m·∫Øn l·ªõn, t√†i l·ªôc d·ªìi d√†o, thu·∫≠n l·ª£i trong m·ªçi vi·ªác.", en: "Double Seven/Great Seven: Great luck, abundant wealth, smooth in all endeavors." },
            '88': { vi: "Ph√°t Ph√°t/Song Ph√°t: Ph√°t t√†i ph√°t l·ªôc g·∫•p b·ªôi, c√¥ng vi·ªác v√† cu·ªôc s·ªëng ƒë·ªÅu ph√°t tri·ªÉn.", en: "Double Growth: Multiplies wealth and prosperity, growth in both work and life." },
            '99': { vi: "Tr∆∞·ªùng C·ª≠u/Vƒ©nh C·ª≠u: Vƒ©nh c·ª≠u, tr∆∞·ªùng t·ªìn, may m·∫Øn m√£i m√£i, b·ªÅn v·ªØng theo th·ªùi gian.", en: "Eternity: Forever, lasting, eternal luck, enduring over time." },
            
            '15': { vi: "Sinh Ph√∫c: Sinh ra may m·∫Øn, ph√∫c l·ªôc.", en: "Born Fortune: Gives rise to luck and blessings." },
            '45': { vi: "B·ªën M√πa Sinh: Sinh s√¥i n·∫£y n·ªü quanh nƒÉm.", en: "Four Seasons Born: Flourishing year-round." },
            '46': { vi: "T·ª© L·ªôc: B·ªën m√πa l·ªôc, t√†i l·ªôc d·ªìi d√†o.", en: "Four Prosperity: Abundant wealth all year." },
            '56': { vi: "Sinh L·ªôc: Sinh ra t√†i l·ªôc.", en: "Born Prosperity: Gives rise to wealth." },
            '59': { vi: "Ng≈© C·ª≠u: Ph√∫c ƒë·ª©c tr∆∞·ªùng c·ª≠u, vi√™n m√£n.", en: "Five Nine: Eternal blessings, completeness." },
            '69': { vi: "L·ªôc C·ª≠u: L·ªôc m√£i m√£i, tr∆∞·ªùng c·ª≠u.", en: "Prosperity Forever: Wealth forever, eternal." },
            '78': { vi: "Th·∫•t Ph√°t: Ph√°t ƒë·∫°t thu·∫≠n l·ª£i.", en: "Seven Growth: Smooth prosperity." },
            '89': { vi: "ƒê·∫°i Ph√°t C·ª≠u: Ph√°t tri·ªÉn b·ªÅn v·ªØng, l√¢u d√†i.", en: "Great Eternal Growth: Sustainable, long-term development." },

            // Patterns like Tam Hoa (XXX), T·ª© Qu√Ω (XXXX) - Check last 3 or 4 digits
            // Example for T·ª© Qu√Ω (XXXX) in last 4 digits
            'XXXX': (num, lang) => { // Placeholder, needs actual check
                if (num[0] === num[1] && num[1] === num[2] && num[2] === num[3]) {
                    const digit = num[0];
                    if (['6','8','9'].includes(digit)) {
                        return lang === 'vi' ? `T·ª© Qu√Ω ${digit}: R·∫•t may m·∫Øn, t√†i l·ªôc d·ªìi d√†o, quy·ªÅn l·ª±c, ƒë·ªãa v·ªã cao.` : `Quadruple ${digit}: Very lucky, abundant wealth, power, high status.`;
                    } else if (['1','2','3','5','7'].includes(digit)) {
                        return lang === 'vi' ? `T·ª© Qu√Ω ${digit}: V·ª´a ph·∫£i, c√≥ gi√° tr·ªã ri√™ng, ·ªïn ƒë·ªãnh.` : `Quadruple ${digit}: Moderate, has its own value, stable.`;
                    } else if (['4','0'].includes(digit)) {
                        return lang === 'vi' ? `T·ª© Qu√Ω ${digit}: C√≥ th·ªÉ kh√¥ng t·ªët, c·∫ßn c√¢n nh·∫Øc ho·∫∑c xem x√©t k·ªπ. (V√≠ d·ª• 4444 l√† T·ª© T·ª≠)` : `Quadruple ${digit}: May not be good, needs consideration or careful review. (e.g. 4444 is Four Deaths).`;
                    }
                }
                return null;
            },
            // Example for Tam Hoa (XXX) in last 3 digits
            'XXX': (num, lang) => { // Placeholder, needs actual check
                const lastThree = num.slice(-3);
                if (lastThree[0] === lastThree[1] && lastThree[1] === lastThree[2]) {
                    const digit = lastThree[0];
                    if (['6','8','9'].includes(digit)) {
                        return lang === 'vi' ? `Tam Hoa ${digit}: May m·∫Øn, t√†i l·ªôc t·ªët, c√¥ng danh thu·∫≠n l·ª£i.` : `Triple ${digit}: Lucky, good wealth, smooth career.`;
                    } else if (['1','2','3','5','7'].includes(digit)) {
                        return lang === 'vi' ? `Tam Hoa ${digit}: B√¨nh th∆∞·ªùng, c√≥ √Ω nghƒ©a c√° nh√¢n, ·ªïn ƒë·ªãnh.` : `Triple ${digit}: Normal, has personal meaning, stable.`;
                    } else if (['4','0'].includes(digit)) {
                        return lang === 'vi' ? `Tam Hoa ${digit}: C√≥ th·ªÉ kh√¥ng t·ªët, c·∫ßn th·∫≠n tr·ªçng. (V√≠ d·ª• 444 l√† Tam T·ª≠)` : `Triple ${digit}: May not be good, needs caution. (e.g. 444 is Triple Death).`;
                    }
                }
                return null;
            },
            // G√°nh ƒê·∫£o (ABBA)
            'ABBA': (num, lang) => {
                const lastFour = num.slice(-4);
                if (lastFour[0] === lastFour[3] && lastFour[1] === lastFour[2] && lastFour[0] !== lastFour[1]) {
                    return lang === 'vi' ? `G√°nh ƒê·∫£o (${lastFour}): T·∫°o s·ª± c√¢n b·∫±ng, ·ªïn ƒë·ªãnh, ƒë√¥i khi mang √Ω nghƒ©a ƒë·∫∑c bi·ªát, d·ªÖ nh·ªõ.` : `Palindromic (${lastFour}): Creates balance, stability, sometimes carries special meaning, easy to remember.`;
                }
                return null;
            },
            // S·ªë Ti·∫øn (ABCD) - last 4 digits form an ascending sequence
            'ABCD_Asc': (num, lang) => {
                const lastFour = num.slice(-4);
                if (parseInt(lastFour[0]) < parseInt(lastFour[1]) &&
                    parseInt(lastFour[1]) < parseInt(lastFour[2]) &&
                    parseInt(lastFour[2]) < parseInt(lastFour[3])) {
                    return lang === 'vi' ? `S·ªë Ti·∫øn (${lastFour}): T∆∞·ª£ng tr∆∞ng cho s·ª± thƒÉng ti·∫øn, ph√°t tri·ªÉn kh√¥ng ng·ª´ng.` : `Ascending Series (${lastFour}): Symbolizes continuous advancement and development.`;
                }
                return null;
            },
            // S·ªë L√πi (DCBA) - last 4 digits form a descending sequence
            'DCBA_Desc': (num, lang) => {
                const lastFour = num.slice(-4);
                if (parseInt(lastFour[0]) > parseInt(lastFour[1]) &&
                    parseInt(lastFour[1]) > parseInt(lastFour[2]) &&
                    parseInt(lastFour[2]) > parseInt(lastFour[3])) {
                    return lang === 'vi' ? `S·ªë L√πi (${lastFour}): C√≥ th·ªÉ mang √Ω nghƒ©a ƒëi xu·ªëng, ho·∫∑c ng∆∞·ª£c l·∫°i l√† s·ª± k·∫øt th√∫c ƒë·ªÉ kh·ªüi ƒë·∫ßu m·ªõi.` : `Descending Series (${lastFour}): May signify decline, or conversely, an end to a new beginning.`;
                }
                return null;
            },


            // Bad numbers (simplified common beliefs)
            '49': { vi: "S·ªë x·∫•u: 'ƒê·∫°i h·∫°n', 'Kh√≥ khƒÉn', 'Ch·∫øt ch√≥c'. Th∆∞·ªùng tr√°nh d√πng.", en: "Bad number: 'Great hardship', 'Difficulty', 'Death'. Often avoided." },
            '53': { vi: "S·ªë x·∫•u: 'Kh√≥ khƒÉn', 'Tai ∆∞∆°ng'. Th∆∞·ªùng tr√°nh d√πng.", en: "Bad number: 'Difficulty', 'Misfortune'. Often avoided." },
            '04': { vi: "T·ª© T·ª≠: Kh√¥ng may m·∫Øn, ƒëi·ªÅm x·∫•u, c√≥ th·ªÉ li√™n quan ƒë·∫øn m·∫•t m√°t. (t·ª© ƒë·ªçc tr·∫°i th√†nh t·ª≠)", en: "Four Death: Unlucky, bad omen, possibly related to loss. (t·ª© sounds like t·ª≠ - death)." },
            '13': { vi: "Th·∫≠p Tam: S·ªë kh√¥ng may m·∫Øn, c√≥ th·ªÉ g·∫∑p tr·ªü ng·∫°i, r·∫Øc r·ªëi.", en: "Thirteen: Unlucky number, may encounter obstacles, trouble." },
            '44': { vi: "Song T·ª≠/T·ª© T·ª≠: ƒêi·ªÅm x·∫•u, r·ªßi ro cao. (t·ª© ƒë·ªçc tr·∫°i th√†nh t·ª≠)", en: "Double Death/Four Deaths: Bad omen, high risk. (t·ª© sounds like t·ª≠ - death)." },
            '74': { vi: "Th·∫•t T·ª≠: M·∫•t m√°t, ti√™u hao. (th·∫•t ƒë·ªçc tr·∫°i th√†nh m·∫•t, t·ª© ƒë·ªçc tr·∫°i th√†nh t·ª≠)", en: "Lost Death: Loss, depletion. (th·∫•t sounds like lost, t·ª© sounds like death)." }
        };

        const lastTwoDigits = lastFourDigits.slice(-2);
        const lastThreeDigits = lastFourDigits.slice(-3);
        const lastFullFourDigits = lastFourDigits; // Use full 4 digits for patterns

        // Check specific 2-digit meanings first
        if (meanings[lastTwoDigits]) {
            return meanings[lastTwoDigits][lang];
        }

        // Check for 3-digit patterns (e.g., Tam Hoa)
        if (meanings['XXX'] && meanings['XXX'](lastFullFourDigits, lang)) { // Pass full 4 digits to check last 3
            return meanings['XXX'](lastFullFourDigits, lang);
        }

        // Check for 4-digit patterns (e.g., T·ª© Qu√Ω, G√°nh ƒê·∫£o, S·ªë Ti·∫øn, S·ªë L√πi)
        if (meanings['XXXX'] && meanings['XXXX'](lastFullFourDigits, lang)) {
            return meanings['XXXX'](lastFullFourDigits, lang);
        }
        if (meanings['ABBA'] && meanings['ABBA'](lastFullFourDigits, lang)) {
            return meanings['ABBA'](lastFullFourDigits, lang);
        }
        if (meanings['ABCD_Asc'] && meanings['ABCD_Asc'](lastFullFourDigits, lang)) {
            return meanings['ABCD_Asc'](lastFullFourDigits, lang);
        }
        if (meanings['DCBA_Desc'] && meanings['DCBA_Desc'](lastFullFourDigits, lang)) {
            return meanings['DCBA_Desc'](lastFullFourDigits, lang);
        }
        
        return lang === 'vi' ? "√ù nghƒ©a ƒëu√¥i s·ªë ch∆∞a ƒë∆∞·ª£c c·∫≠p nh·∫≠t ƒë·∫ßy ƒë·ªß cho d·∫°ng s·ªë n√†y." : "Suffix meaning not fully updated for this number pattern.";
    }

    function getTotalScoreMeaning(score, lang) {
        // This function is currently not directly used in the HTML but can be for more detailed score breakdowns
        // Example:
        if (score >= 80) return lang === 'vi' ? "ƒêi·ªÉm t·ªïng h√≤a r·∫•t cao, ƒë·∫°i c√°t ƒë·∫°i l·ª£i." : "Very high overall score, great fortune.";
        if (score >= 60) return lang === 'vi' ? "ƒêi·ªÉm kh√° cao, mang l·∫°i nhi·ªÅu may m·∫Øn." : "Quite high score, brings much luck.";
        if (score >= 40) return lang === 'vi' ? "ƒêi·ªÉm trung b√¨nh, c√≥ th·ªÉ ch·∫•p nh·∫≠n ƒë∆∞·ª£c." : "Average score, acceptable.";
        return lang === 'vi' ? "ƒêi·ªÉm th·∫•p, c√≥ th·ªÉ c·∫ßn c√¢n nh·∫Øc." : "Low score, may need consideration.";
    }

    const showLoading = (messageKey, showSpinner = true) => {
        spinner.style.display = showSpinner ? 'block' : 'none';
        checkmarkWrapper.classList.remove('show');
        // Remove existing message if any
        let messageP = loadingOverlay.querySelector('p');
        if (!messageP) {
            messageP = document.createElement('p');
            loadingOverlay.appendChild(messageP);
        }
        messageP.textContent = translations[currentLang][messageKey];
        messageP.style.color = 'white';
        messageP.style.fontSize = '1.2em';
        
        loadingOverlay.classList.add('show');
    };

    const hideLoading = (showCheckmark = false, messageKey = null) => {
        spinner.style.display = 'none';
        if (showCheckmark) {
            checkmarkWrapper.classList.add('show');
            const messageP = loadingOverlay.querySelector('p');
            if (messageP && messageKey) {
                messageP.textContent = translations[currentLang][messageKey];
            }
        } else {
            loadingOverlay.classList.remove('show');
            checkmarkWrapper.classList.remove('show');
        }
        setTimeout(() => {
            loadingOverlay.classList.remove('show'); // Ensure it hides after checkmark animation
            const messageP = loadingOverlay.querySelector('p');
            if (messageP) {
                messageP.remove(); // Clean up the message element
            }
        }, showCheckmark ? 1000 : 0); // Keep loading screen for a bit to show checkmark
    };

    const displayResult = (analysisResultHtml) => {
        resultDiv.innerHTML = analysisResultHtml;
        resultDiv.scrollTop = 0; // Scroll to top of result
    };

    const validateInputs = (checkPhoneNumber = true) => {
        const fullName = fullNameInput.value.trim();
        const dobString = dobInput.value;
        const phoneNumber = phoneNumberInput.value.trim();

        if (!fullName) {
            alert(translations[currentLang].invalidName);
            return false;
        }
        if (!dobString) {
            alert(translations[currentLang].invalidDate);
            return false;
        }
        if (checkPhoneNumber) {
            if (phoneNumber.length !== 10) {
                alert(translations[currentLang].validPhoneLength);
                return false;
            }
            if (!phoneNumber.startsWith('0')) {
                alert(translations[currentLang].invalidPhonePrefix);
                return false;
            }
        }
        return true;
    };

    checkButton.addEventListener('click', async () => {
        if (!validateInputs(true)) { // Validate phone number too for "Ti√™n Tri Ngay"
            return;
        }

        const fullName = fullNameInput.value.trim();
        const dobString = dobInput.value;
        const phoneNumber = phoneNumberInput.value.trim();

        showLoading('processing');
        findGoodNumberButton.disabled = true; // Disable until analysis is done
        checkButton.disabled = true;

        try {
            // Simulate processing time
            await new Promise(resolve => setTimeout(resolve, 1500)); 
            
            const analysisResult = analyzeNumberMeaning(phoneNumber, fullName, dobString);
            displayResult(analysisResult.html);
            hideLoading(true, 'introSuccess'); // Use introSuccess as a generic "done" message
        } catch (error) {
            console.error("Error analyzing number:", error);
            alert(`${translations[currentLang].errorOccurred} ${error.message || ''}`);
            hideLoading(false);
        } finally {
            findGoodNumberButton.disabled = false;
            checkButton.disabled = false;
        }
    });

    findGoodNumberButton.addEventListener('click', () => {
        // Only validate name and DOB for "Find Good Number" initial click
        if (!validateInputs(false)) { 
            return;
        }

        carrierModal.style.display = 'flex'; // Show the modal
    });

    closeButton.addEventListener('click', () => {
        carrierModal.style.display = 'none';
    });

    window.addEventListener('click', (event) => {
        if (event.target === carrierModal) {
            carrierModal.style.display = 'none';
        }
    });

    searchGoodNumberButton.addEventListener('click', async () => {
        const selectedCarrier = document.querySelector('input[name="carrier"]:checked');
        if (!selectedCarrier) {
            alert(translations[currentLang].noCarrierSelected);
            return;
        }

        const fullName = fullNameInput.value.trim();
        const dobString = dobInput.value;
        const carrierValue = selectedCarrier.value; 

        carrierModal.style.display = 'none'; // Hide modal

        showLoading('findingGoodNumber');
        findGoodNumberButton.disabled = true;
        checkButton.disabled = true;

        try {
            const goodNumberAnalysis = await findBestFengShuiNumber(fullName, dobString, carrierValue);
            if (goodNumberAnalysis) {
                displayResult(goodNumberAnalysis.html);
                hideLoading(true, 'goodNumberFound');
            } else {
                displayResult(`<p class="initial-message">${translations[currentLang].noGoodNumber}</p>`);
                hideLoading(false);
            }
        } catch (error) {
            console.error("Error finding good number:", error);
            alert(`${translations[currentLang].errorOccurred} ${error.message || ''}`);
            hideLoading(false);
        } finally {
            findGoodNumberButton.disabled = false;
            checkButton.disabled = false;
        }
    });

    // Function to generate a random 10-digit phone number with a specific prefix
    function generateRandomPhoneNumber(carrierValue) {
        let prefixBase;
        // Map carrier names to common 2-digit prefixes for random generation
        // Note: This is a simplified approach. Real carrier prefixes are more complex.
        switch (carrierValue) {
            case 'Viettel': prefixBase = ['32', '33', '34', '35', '36', '37', '38', '39', '86', '96', '97', '98'][Math.floor(Math.random() * 12)]; break; // Generates 03x or 086/09x
            case 'Mobifone': prefixBase = ['70', '79', '77', '76', '78', '89', '90', '93'][Math.floor(Math.random() * 8)]; break; // Generates 07x or 089/09x
            case 'Vinaphone': prefixBase = ['81', '82', '83', '84', '85', '88', '91', '94'][Math.floor(Math.random() * 8)]; break; // Generates 08x or 09x
            case 'Vietnamobile': prefixBase = ['56', '58', '92'][Math.floor(Math.random() * 3)]; break; // Generates 05x or 092
            case 'Gmobile': prefixBase = ['59', '99'][Math.floor(Math.random() * 2)]; break; // Generates 059 or 099
            default: prefixBase = ['3','7','8','9'][Math.floor(Math.random() * 4)] + Math.floor(Math.random() * 10).toString(); // Fallback to a random 0xx prefix
        }

        let num = '0' + prefixBase;
        // Complete to 10 digits
        while (num.length < 10) {
            num += Math.floor(Math.random() * 10).toString();
        }
        return num;
    }

    // Function to find the best feng shui number (now returns full analysis)
    async function findBestFengShuiNumber(fullName, dobString, carrierValue) {
        let bestAnalysisResult = null;
        let highestScore = -Infinity;
        const maxAttempts = 5000; // Increased attempts for better chances to find a good one
        const goodEnoughScore = 60; // Define what "good enough" means

        for (let i = 0; i < maxAttempts; i++) {
            const testNumber = generateRandomPhoneNumber(carrierValue);
            try {
                const analysis = analyzeNumberMeaning(testNumber, fullName, dobString);
                if (analysis.overallScore > highestScore) {
                    highestScore = analysis.overallScore;
                    bestAnalysisResult = analysis;
                }
                // If a "good" enough number is found, stop early
                if (highestScore >= goodEnoughScore) { 
                    break;
                }
            } catch (e) {
                // console.warn(`Skipping invalid number ${testNumber} or analysis error: ${e.message}`);
                // Don't warn too much for generated invalid numbers, just skip
            }
            // Add a small delay to prevent freezing the UI, but keep it fast enough
            if (i % 200 === 0) { // Only yield control every 200 iterations
                await new Promise(resolve => setTimeout(resolve, 5)); 
            }
        }

        return bestAnalysisResult;
    }
});